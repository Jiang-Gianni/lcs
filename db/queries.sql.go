// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: queries.sql

package db

import (
	"context"
)

const countQuestionByTitleSlug = `-- name: CountQuestionByTitleSlug :one
select count(*) from question where title_slug = ?
`

func (q *Queries) CountQuestionByTitleSlug(ctx context.Context, titleSlug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuestionByTitleSlug, titleSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllQuestion = `-- name: GetAllQuestion :many
select id, question_id, link, title, title_slug, is_paid_only, difficulty, content from question
`

func (q *Queries) GetAllQuestion(ctx context.Context) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, getAllQuestion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Link,
			&i.Title,
			&i.TitleSlug,
			&i.IsPaidOnly,
			&i.Difficulty,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditors = `-- name: GetEditors :many
select id, question_id, lang, lang_slug, code from editor where question_id = ? and lang_slug = ?
`

type GetEditorsParams struct {
	QuestionID string
	LangSlug   string
}

func (q *Queries) GetEditors(ctx context.Context, arg GetEditorsParams) ([]Editor, error) {
	rows, err := q.db.QueryContext(ctx, getEditors, arg.QuestionID, arg.LangSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Editor
	for rows.Next() {
		var i Editor
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Lang,
			&i.LangSlug,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHints = `-- name: GetHints :many
select id, question_id, hint from hint where question_id = ?
`

func (q *Queries) GetHints(ctx context.Context, questionID string) ([]Hint, error) {
	rows, err := q.db.QueryContext(ctx, getHints, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hint
	for rows.Next() {
		var i Hint
		if err := rows.Scan(&i.ID, &i.QuestionID, &i.Hint); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEditor = `-- name: InsertEditor :exec
insert into editor(question_id, lang, lang_slug, code) values (?, ?, ?, ?)
`

type InsertEditorParams struct {
	QuestionID string
	Lang       string
	LangSlug   string
	Code       string
}

func (q *Queries) InsertEditor(ctx context.Context, arg InsertEditorParams) error {
	_, err := q.db.ExecContext(ctx, insertEditor,
		arg.QuestionID,
		arg.Lang,
		arg.LangSlug,
		arg.Code,
	)
	return err
}

const insertHint = `-- name: InsertHint :exec
insert into hint(question_id, hint) values (?, ?)
`

type InsertHintParams struct {
	QuestionID string
	Hint       string
}

func (q *Queries) InsertHint(ctx context.Context, arg InsertHintParams) error {
	_, err := q.db.ExecContext(ctx, insertHint, arg.QuestionID, arg.Hint)
	return err
}

const insertQuestion = `-- name: InsertQuestion :exec
insert into question(question_id, link, title, title_slug, is_paid_only, difficulty, content) values (?, ?, ?, ?, ?, ?, ?)
`

type InsertQuestionParams struct {
	QuestionID string
	Link       string
	Title      string
	TitleSlug  string
	IsPaidOnly bool
	Difficulty string
	Content    string
}

func (q *Queries) InsertQuestion(ctx context.Context, arg InsertQuestionParams) error {
	_, err := q.db.ExecContext(ctx, insertQuestion,
		arg.QuestionID,
		arg.Link,
		arg.Title,
		arg.TitleSlug,
		arg.IsPaidOnly,
		arg.Difficulty,
		arg.Content,
	)
	return err
}
